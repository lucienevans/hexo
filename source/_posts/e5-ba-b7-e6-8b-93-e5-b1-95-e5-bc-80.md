title: 康拓展开基本介绍
tags:
  - hash
  - 离散数学
id: 268
categories:
  - 算法
date: 2014-10-05 16:37:16
---


给出n个互不相同的字符, 并给定它们的相对大小顺序,这样n个字符的所有排列也会有一个顺序. 现在任给一个排列,求出在它后面的第i个排列.
这是一个典型的康拓展开应用，首先我们先阐述一下什么是康拓展开。

# 康拓展开

所谓康拓展开是指把一个字符序列展开成如下形式：$X = \sum\limits_{i = 1}^n {a(i)*(i - 1)!} $,

其中$n$是字符的总共数目，$a[i]$是该字符在未出现的字符中的大小序号。

这个公式看起来很让人头疼，我们来举个例子说明。例如有一个字符数组$s=[A,B,C,D]$，数组的排列顺表示它们的大小顺序，即$A>B>C>D$。对于它的一个排列$a=[D,B,A,C]$，我们可以求出其康拓展开的值（即该排列的大小）：
<!--more -->

1.  根据上述康拓展开的公式，我们知道$n=4$；
2.  $a[4]=D$，现在未出现的字符有$[A,B,C,D]$，所以$a[4]=3$；
3.  $a[3]=B$，现在未出现的字符有$[A,B,C]$，所以$a[3]=1$；
4.  $a[2]=A$，现在未出现的字符有$[A,C]$，所以$a[2]=0$；
5.  $a[1]=C$，现在未出现的字符有$[C]$，所以$a[1]=0$；（因为到$a[1]$时，未出现的字符只有$a[1]$，所以$a[1]$一定等于0）
6.  所以$X=3 \times 3!+1 \times 2!+0 \times 1!+0 \times 0!=20$。
我们得到比$a$小的排列有20个，也即$a$这个排列在s的全排列中排第20。（从0开始）

以下是代码实现：
```
#include stdio.h;

const int fac[]={1,1,2,6,24,120,720,5040,40320,362880};	//各阶乘结果
/************************************************************************/
/*求得给定序列在全序列中的大小，即康拓展开 
*/
/************************************************************************/
int Cantor(int *s,int n){
	int i,j,num;
	num=0;
	for(i=0;i&lt;n;i++){	//对于序列中每一位
		int cnt=0;
		for(j=i+1;j&lt;n;j++){	//计算比该位小的字符
			if(s[j]&lt;s[i])
				cnt++;
		}
		num+=cnt*fac[n-i-1];
	}
	return num;
}

int main(){
	int a[4]={1,3,2,4};	//表示排列1324
	int index=Cantor(a,4);
	printf("The index of the array is %d\n",index);
	return 0;
}
```

# 逆康拓展开

如果给定你一个序列在全排列中的位置，让你求该序列的具体表示，这就是逆康拓展开。

还是用上述的例子：已知$s=[A,B,C,D],X(a)=20$，怎么求$s$？

1.  用$20/3!=3$余2，得在未出现的字符中比$a[4]$小的有3个，则$a[4]=D$；
2.  用$2/2!=1$余0，得在未出现的字符中比$a[3]$小的有1个，则$a[3]=B$；
3.  用$0/1!=0$余0，得在未出现的字符中$a[2]$小的有0个，则$a[2]=A$；
4.  最后只剩$a[1]=C$。
以下是代码实现：
```
#include&lt;stdio.h&gt;
#include&lt;malloc.h&gt;
#include&lt;string.h&gt;

const int fac[]={1,1,2,6,24,120,720,5040,40320,362880};	//各阶乘结果

/************************************************************************/
/*根据序列大小求序列具体表达，即逆康拓展开 
                                                                     */
/************************************************************************/
void CantorReverse(int index,int* rlt,int n){
	index--;	//排序从0开始
	bool* flag=(bool*)malloc(n*sizeof(bool));	//记录字符是否出现
	memset(flag,false,n*sizeof(bool));
	int i,cnt,j;
	cnt=0;
	for(i=0;i&lt;n;i++){
		int tmp=index/fac[n-1-i];	//tmp表示未出现的字符中有tmp个字符比该字符小
		index%=fac[n-1-i];
		for(j=0;j&lt;=tmp;j++){	//这里的tmp是变化的，与MATLAB里不同！
			if(flag[j]) tmp++;
		}
		rlt[cnt++]=tmp+1;
		flag[tmp]=true;
	}
}

int main(){
	int i,len=4,index=3;
	int* rlt=(int*)malloc(4*sizeof(int));
	CantorReverse(index,rlt,len);
	for(i=0;i&lt;len;i++){
		printf("%d ",rlt[i]);
	}
	printf("\n");
	return 0;
}
```

# 总结

康拓展开和逆康拓展开可以用于hash表的构造，将字符序列进行hash化。
