title: 有关交通最短路的一些技术
tags:
  - 寻路算法
id: 65
categories:
  - 交通流最短路
date: 2014-08-07 13:59:56
---

<address>本文中讨论的最短路问题都是一对一的最短路问题，即从一个起点到一个终点的最短路求法。</address>

## 一、Dijsktra算法

这个无需多说，是求图最短路的经典算法。要注意的是经典Dijsktra算法是求一个点到图中其他所有点的最短路，在我们求一对一最短路时，当搜索到终点即终止Dijsktra算法。

<!-- more -->
## 二、优先队列

使用优先队列可以有效降低Dijsktra算法复杂度。使用堆可以将复杂度降到O(mlog(n))（m是图中的边数，n是图中的点数）；使用斐波拉契堆可以将复杂度降到O(mloglog(n))；使用复杂的整数优先队列（a sophisticated integer priority queue）可以将复杂度降到O(m+nloglog(n))；还有其他的一系列的优化算法。最后在一个任意有向图中，若图中的边长都是服从[0,1]之间的均匀分布，则有一个线性复杂度的最短路算法。

## 三、双向广度搜索

同时对于起点终点进行Dijsktra算法，当这两个Dijsktra算法有交点时停止，这时候就发现了一条最短路。之后的很多最短路搜索算法都借鉴了双向广度搜索的思想。

## 四、基于欧几里得距离的A*算法

A*算法是一个启发式的算法，它与Dijsktra算法和BFS算法不同之处在于：它在寻找最短路的时候设置了一个启发式函数h(n)，它每次选择f(n)=g(n)+h(n)最小的点作为路径，其中，g(n)是从起点到该点的花费，h(n)是启发函数，它表示从该点到终点的花费，我们可以通过图的一些性质大概的预测它的值，比如在交通图中，最简单的，我们以该点到终点的欧几里得距离作为h(n)的预测值。但是，事实证明基于欧几里得的A*算法只能稍稍减少搜索时间，而增加了很多的开销，实用效果不是很好。

## 五、基于地标的A*算法

为了更有效率的预测启发式函数h(n)，我们可以在图中选取一些具有代表性的地标点，再预计算图中各点到地标的距离，最后利用三角形定理计算出h(n)。比如现在我们要计算起点s到终点t的最短路，我们选取一个地标L，对于图中每一个点v我们计算出v到L的距离d(v,L)，那么根据三角形定理：d(v,t)&gt;=d(v,L)-d(t,L)，这样我们就得到h(n)的一个估计值。但是显然这样做的缺点就是需要大量的储存空间，所以实际应用中我们只储存一些比较重要的地点到地标的距离值。

## 六、预计算群集距离

从五中我们可以得到一些启发：预计算一些在寻最短路中常用距离可以大大的提高寻路算法的速度。所以我们将交通图分成一系列的子图，并预计算这些子图的最短距离，当我们进行最短寻路时既可以利用这些预处理好的最短距离，能够减少很多计算量，而且与五相比，所需的储存空间也大大减少。

## 七、边标识

我们将图分成k个区域，对于每条边e和每个区域r，如果e在到r的最短路上，则置其flag为真。当我们使用Dijsktra算法计算最短路时，假设终点在某个区域r内，那么对于每条边，只有其到r的flag为真时，我们才对其进行松弛操作。这样就大大减少了寻路时间。

&nbsp;

寻路算法的寻路过程是简单的，而预处理的过程则需要很好的设计，最简单的预处理思路就是将图中所有点之间的最短路求出来，但显然效率十分低下；一个更好的预处理思路是预计算一些寻路中经常使用的一些路径；更进一步的思路是将大的图分割成小图，将大型问题转化成小型问题，再将各个小图之间的最短路预计算出。
